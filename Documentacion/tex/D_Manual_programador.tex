\lstset{basicstyle=\ttfamily,
	showstringspaces=false,
	commentstyle=\color{red},
	keywordstyle=\color{blue},
	frame=single
}

\apendice{Documentación técnica de programación}

\section{Introducción}
En este apéndice se va a definir todo aquello que es necesario conocer para que se pueda continuar con el desarrollo del proyecto, desde su estructura hasta una breve descripción de como instalar la aplicación y configurar nuestro entorno de trabajo para llevar a cabo el desarrollo.

\section{Estructura de directorios}\label{cap:Estructura}
En este proyecto, aunque al principio se siguieron distintos tutoriales sobre cómo crear la estructura de directorios y ficheros, al final se optó por la opción que propone Azure. De este modo, a la hora de realizar el despliegue no tendríamos ningún tipo de problema, ya que esta plataforma requiere determinados ficheros de configuración que se explicarán a continuación.
La estructura del proyecto se divide en:
\dirtree{%
	.1 / Directorio raíz.
	.2 Documentación/ -Documentación del proyecto.
	.3 img/ -Imágenes de la documentación.
	.3 tex/ -Secciones de la documentación.
	.3 anexos.pdf -Anexos del proyecto.
	.3 memoria.pdf -Memoria del proyecto.
	.2 HolaMundo/ -App web básica.
	.2 Metrominuto/ -Directorio del proyecto web.
	.3 metrominuto\_app/ -Aplicación web.
	.4 main/ -Directorio que inicializa el blueprint de la aplicación.
	.5 \texttt{init.py} -Inicialización.
	.5 forms.py -Contiene los formularios de la aplicación.
	.5 routes.py -Contiene las rutas de la aplicación.
	.4 static/ -ficheros JavaScript.
	.5 css/ -Estilos.
	.5 img/ -Imágenes.
	.5 templates/ -ficheros HTML.
	.4 init.py -Inicializa la aplicación.
	.4 calculateRoute.py -Operaciones con el API de Google.
	.4 globals.py -Variables globales del proyecto.
	.4 graphs.py -Operaciones con grafos.
	.4 svgfunctions.py -Operaciones para dibujar.
	.4 webapp.py .
	.3 config.py -Fichero de configuración.
	.3 metrominuto.py -Punto de entrada para iniciar la aplicación.
	.3 metrominuto.txt -Fichero necesario para desplegar en Azure.
	.3 requirements.txt -Dependencias necesarias para ejecutar el proyecto.
}

\section{Manual del programador}
En este apartado se explican los puntos a tener en cuenta por futuros desarrolladores que tengan la intención de mantener o mejorar el proyecto.
\subsection{Dibujado de grafos}
El principal objetivo de este proyecto se basa en obtener un grafo final de manera que éste sea fácilmente entendible por todos. Es por ello que a la hora de dibujar dicho grafo se plantean cuestiones y problemas como dónde colocar los textos, a que distancias, cómo orientar esos textos$\dots$

Estos problemas han resultado de gran complejidad en el desarrollo final del proyecto, ya que como mencionaba antes, es el resultado final de todo el proyecto. Para solucionar el problema de que los textos no se superpongan, tanto en las líneas o \textit{caminos} como en los puntos o \textit{paradas}, he tenido en cuenta dos opciones:
\begin{itemize}
	\item \textbf{Discretización de las líneas:} este método consiste en dividir la parte de la línea no muy lejana al punto medio en varios puntos separados por una distancia $\delta$. De este modo, conociendo las dimensiones del texto que queremos colocar, y siendo la posición conocida, podemos calcular si el texto se superpone a la línea. La elección de puntos cercanos al punto medio se debe a que la intención es colocar dicho texto en una poción centrada respecto de los dos puntos a los que hace referencia. En el caso de colocar el texto que referencia a los puntos o \textit{paradas} la división en puntos separados $\delta$ se haría entorno al punto que se quiere referenciar.
	\item \textbf{Superposición de cuadrados:} Este método consiste en calcular primeramente el cuadrado que contiene el texto. Una vez que sabemos esto, podemos construir varios rectángulos en torno al punto donde queremos colocar el texto, tanto a un lado de la línea como al otro. Posteriormente, dividiremos la línea que une los dos puntos para los que queremos colocar el texto en cuatro cuadrados partiendo del punto medio. De este modo, en dos de ellos la diagonal sería parte de la línea que une los puntos, mientras que en los otros dos no habría nada. De esto modo, y conociendo la dirección de la línea podemos calcular si, sobre los rectángulos que forman parte de la línea, existe una superposición con alguno de los posibles rectángulos del texto. En el caso del texto que referencia el punto, el rectángulo, o en este caso cuadrado, que se construye sería el que contiene al círculo y se evaluaría el rectángulo correspondiente del que la línea forma parte.
\end{itemize}

\section{Aplicaciones utilizadas}
Para el desarrollo de este proyecto se tuvieron en cuenta principalmente dos editores de texto y dos herramientas para mantener el control de versiones.

\begin{itemize}
	\item \textbf{Visual Studio Code} 
	\item \textbf{PyCharm}
	\item \textbf{GitHub}
	\item \textbf{GitCraken}
\end{itemize}
Después de analizar y configurar ambos editores de texto, se llegó a la conclusión de que era mucho mas cómodo y útil utilizar PyCharm, ya que ofrece una configuración mas sencilla, además de permitir importar diversas librerías de una manera mas amigable. También ofrece la posibilidad de seguir los estándares de programación \textit{PEP8} y \textit{ECMAScript}.

\section{Instalación y configuración}
Para la instalación del proyecto se explicarán los pasos a seguir en un sistema operativo de Linux, que en este caso se trata de la versión Linux Mint 18.3 Sylvia.

\subsection{Python}

Este proyecto está desarrollado con la versión 3.6.3. Python se puede descargar desde el siguiente enlace: 
\url{https://www.python.org/downloads/}

\subsection{Instalación y configuración de PyCharm}
Este \textit{IDE} tiene distribución para Linux, además de permitir a estudiantes usar la versión profesional. Para su instalación podemos usar la \textit{snap store} de Linux, que en caso de no tenerla instalada tenemos que ejecutar el siguiente comando:

\renewcommand{\lstlistingname}{Instalar PyCharm}% Listing -> Algorithm
\renewcommand{\lstlistlistingname}{List of \lstlistingname s}
\begin{lstlisting}[language=bash,caption={Instalar snapd}]
$ sudo apt update
$ sudo apt install snapd
\end{lstlisting}

Después de tener instalado esto, ejecutaríamos:
\begin{lstlisting}[language=bash,caption={Instalar PyCharm}]
$ sudo snap install 
	pycharm-community|professional --classic
\end{lstlisting}

Una vez instalado \textit{PyCharm}, la forma más cómoda de obtener el código del proyecto es mediante \textit{git}, usando para ello el comando:

\renewcommand{\lstlistingname}{Configurar PyCharm}% Listing -> Algorithm
\renewcommand{\lstlistlistingname}{List of \lstlistingname s}
\begin{lstlisting}[language=bash,caption={Descargar el repositorio}]
$ git clone <url_del_repositorio>
\end{lstlisting}
Siendo \url{https://github.com/gpm0009/TFG_MetrominutoWeb.git} la URL del 
repositorio.

Para instalar las dependencias ejecutar el comando:
\begin{lstlisting}[language=bash,caption={Instalar requirements.txt}]
$ pip install -r requirements.txt
\end{lstlisting}

\subsection{Claves de Google}
Para la obtención de una \textit{Google API KEY} es necesario obtener los credenciales en  \url{https://console.developers.google.com/apis/credentials}.\\
Una vez registrados en Google, en el caso de que no lo estuviésemos ya, debemos acceder a la \textit{consola}\footnote{\url{https://console.cloud.google.com}} y desplegar el panel de la parte izquierda.
\imagen{panelGoogle}{Panel Google Console}

Hacemos click sobre <<APIs y servicios>> - <<Credenciales>> y después sobre la clave que se nos ha generado anteriormente. Desde el apartado <<Restricciones de API>> podremos seleccionar que servicios queremos que proporcione nuestra clave.\\
En concreto, para este proyecto debemos tener activados:
\begin{itemize}
	\item Directions.
	\item Distance Matrix.
	\item Geocoding.
	\item Maps JavaScript.
	\item Places.
\end{itemize}


Una vez que la tenemos, debemos incluirla en el proyecto. Para ello:
\renewcommand{\lstlistingname}{Google Key}% Listing -> Algorithm
\renewcommand{\lstlistlistingname}{List of \lstlistingname s}
\begin{lstlisting}[language=python,caption={Añadir \texttt{API\_KEY}}]
google_maps=googlemaps.Client(key='GOOGLE_API_KEY')
\end{lstlisting}

Además, no hay que olvidar incluirla en los templates:
\begin{lstlisting}[language=html,caption={Añadir \texttt{API\_KEY} a los templates}]
<script
 src="https://maps.googleapis.com/maps/api/
	 js?key=API_KEY&libraries=places" 
	 type="text/javascript"</script>
\end{lstlisting}

También podemos incluirla como variable de entorno en nuestro editor. De esta manera nos aseguramos de no compartirla al realizar los commints en el control de versiones.
\\
En este caso, en PyCharm se configura de la siguiente manera:
\begin{enumerate}
\item Abrir selector Run Configuration (arriba a la derecha)
\item Edit Configurations...
\item Environmental variables
\item Add or change variables, then click OK 
\end{enumerate}
  
\subsection{\TeX studio}
Esta herramienta para la compilación de documentación \LaTeX{} permite la instalación de diccionarios para aplicar las reglas al texto. Para ello, debemos acceder a:

\renewcommand{\lstlistingname}{Configure \TeX studio}% Listing -> Algorithm
\renewcommand{\lstlistlistingname}{List of \lstlistingname s}
\begin{lstlisting}[language=bash,caption={Añadir diccionario}]
Options -> Configure TeXstudio
Language checking
\end{lstlisting}

Una vez ahí, vemos que nos ofrece dos opciones para buscar diccionarios: \url{https://extensions.openoffice.org/de/search?f[0]=field_project_tags} o \url{https://extensions.libreoffice.org/extensions?getCategories=Dictionary&getCompatibility=any}. Elegimos cualquiera de ellas y descargamos el paquete del diccionario que queramos, y después lo importamos.


\section{Bibliotecas}

\subsection{NetworkX}
Como ya he mencionado, esta biblioteca nos permite trabajar de una forma muy amplia y completa con grafos. A lo largo del proyecto se han usado:
\begin{itemize}
	\item \texttt{graph()}: para crear un grafo no dirigido al que se añadirán nodos y arcos.
	\item \texttt{add\_node()}: Diferentes nodos junto con atributos como la posición obtenida del API de Google y el nombre.
	\item \texttt{add\_edge()}: Arco que conecta dos nodos. Además, los arcos contienen atributos como la distancia real que hay de nodo a nodo o el número de votos que tendrá.
	\item \texttt{get\_edge\_attributes()}: para obtener los valores de un atributo perteneciente a los arcos. Devuelve una lista que contiene el nodo de origen, el nodo destino y el atributo deseado.
	\item \texttt{edges(data=True)}: devuelve los arcos junto con los atributos.
	\item \texttt{nodes(data=True)}: devuelve los nodos junto con los atributos.
	\item \texttt{minimum\_spanning\_edges()}: devuelve un iterador con los arcos que forman el grafo de tal manera que la suma de distancias es la mínima.
	\item \texttt{draw\_networkx()}: para dibujar el grafo.
\end{itemize}

\subsection{Despliegue de la aplicación en Azure}
Antes de incluirlo voy a intertar desplegarlo desde un repositorio git (ya que he elegido pycharm para no decir ahora que uso VS Code).


\section{Compilación, instalación y ejecución del proyecto}
Para el desarrollo de este proyecto se ha usado PyCharm, por lo que esta guía esta orientada a este editor. Para Visual Studio Code puede visitarse el enlace \url{https://code.visualstudio.com/docs/python/tutorial-flask}, ya que la creación y ejecución del entorno virtual no es igual.

\subsection{Python}
Este proyecto está desarrollado con la versión 3.7.5, pero con para desarrollar la mínima es 3.6. Python se puede descargar desde el siguiente enlace: \url{https://www.python.org/downloads/}.

\subsection{Instalación}
La forma más cómoda de obtener todo el proyecto es mediante \textit{git}, usando el comando:
\renewcommand{\lstlistingname}{Isntalación}% Listing -> Algorithm
\renewcommand{\lstlistlistingname}{List of \lstlistingname s}
\begin{lstlisting}[language=python,caption={Descargar el repositorio.}]
 $ git clone <url_del_repositiorio>
\end{lstlisting}
Siendo \url{https://github.com/gpm0009/TFG_MetrominutoWeb} la URL del repositorio en \textit{GitHub}.
\\
Ya con el proyecto descargado, el siguiente paso es instalar las dependencias. Aunque se pueden instalar sobre la instalación global de Python, es recomendable usar un entorno virtual. Para ello, debemos abrir el directorio del proyecto desde Pycharm, y una vez que lo tengamos ir a \textit{Files - Settings - Project Interpreter - Add}, y seleccionar la opción de \textit{Virtual Envirorment} y a continuación creamos uno nuevo.
\imagen{NewVirtualEnvirorment}{Creación del entorno virtual.}
Después, el editor detectará automáticamente el fichero \textit{requirements.txt} y nos preguntará si queremos instalar las dependencias, a lo que le diremos que sí. De no ser así, hay que abrir la terminal en la parte inferior del editor y ejecutar el comando:
\begin{lstlisting}[language=python,caption={Instalar dependencias en el entorno virtual.}]
$ pip -r install requirements.txt
\end{lstlisting}

\subsection{Variables de entorno}
Para que la aplicación funcione correctamente hay que definir las siguientes variables de entorno:
\begin{itemize}
	\item \textbf{\texttt{GOOGLE\_API\_KEY}:} clave obtenida anteriormente necesaria para obtener datos de Google.
	\item \textbf{\texttt{SECRET\_KEY}:} clave necesaria por Flask.
	\item \textbf{\texttt{ENVIRORMENT}:} en el que se está actualmente: development o production.
\end{itemize}

\subsection{Ejecución}
Para la ejecución desde el editor, es necesario que hagamos una última configuración. Debemos ir a la parte superior derecha del editor y seleccionar \textit{Edit Configurations$\dots$}
\imagen{ejecucion}{Ejecución del proyecto.}

En esta pantalla tenemos que elegir el punto de entrada a la aplicación, que será el fichero \textit{metrominuto.py}, escribir el entorno en el que queremos ejecutar la aplicación y marcar la opción de Debug. Una vez hecho esto, ya podemos ejecutar la aplicación desde el panel superior derecho.

\subsection{Despliegue en Azure}
Para realizar el despligue de la aplicación en Azure es necesario que el proyecto tenga una estructura concreta, ya que serán los servicios de Azure los que instalen las dependencias necesarias y ejecuten el código. 
Para ello, esta estructura en la que se contempla y define en el apartado Estructura de directorios \ref{cap:Estructura}.

He hecho el despliegue usando VS Code, igual no queda bonito decir que lo he usado después de usar PyCharm. Voy a probar a desplegarlo desde git y lo incluyo. 

\section{Pruebas del sistema}
