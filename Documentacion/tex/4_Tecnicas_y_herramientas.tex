\capitulo{4}{Técnicas y herramientas}


\section{Técnicas}

\subsection{Scrum}
Scrum es una metodología de desarrollo ágil la cual proporciona un marco de trabajo y desarrollo de productos. No es un solo proceso, si no que en esta metodología se aplican un conjunto de buenas prácticas y procesos para que el producto final sea de la mejor calidad posible.
El principal elemento del Scrum consiste en los llamados Sprints, que son ciclos de trabajo de una semana de duración. Este periodo sirve para producir un desarrollo o mejora del producto final. Estos sprints están marcados por dos reuniones:
\begin{itemize}
	\item Planificación: en ella se presentan los requisitos o avances que tiene que cumplir el proyecto, a la vez que se estiman los tiempos y se realiza la planificación.
	\item Reunión de revisión: entrega de los requisitos acordados en la reunión de planificación y el equipo analiza el sprint.
\end{itemize}
El uso de esta metodología, junto con las diversas reuniones que se realizan, permite que el producto final sea de mejor calidad ya que en todo momento se conoce el feedback del cliente y se pueden realizar distintos cambios incrementales a medida que avanza el proyecto.
Es una metodología pensada para el trabajo en equipo, por lo que en este proyecto se han mantenido las bases pero se ha adaptado la forma de trabajar, de manera que las reuniones han sido entre los tutores y el alumno y la fecha de la reunión de planificación del Sprint coincide con la fecha de revisión del sprint anterior.


\subsubsection{GitHub}
Para el control de versiones de este proyecto he utilizado GitHub, que es un repositorio en línea que emplea Git. De esta manera tenemos acceso en línea a los diferentes cambios de nuestro proyecto.
Git maneja los distintos archivos del proyecto como un conjunto de copias instantáneas. 


\section{Herramientas}
\subsection{Flask}
Flask es un \textit{framework} de Python que nos permite crear aplicaciones cliente - servidor de una manera mas sencilla, y que no impone ninguna limitación respecto a estructura del proyecto ni a los componentes que usar durante el desarrollo~\cite{grinberg2014flask}.
\\
Ofrece servicios HTTP, pero para poder hacer uso de los contenidos HTML requiere de la utilización del motor de templates \textit{Jinja2}: lenguaje de plantillas que permite insertar datos procesados y texto predeterminado.

\subsection{Bibliotecas}

\subsubsection{Networkx}
NetworkX es la biblioteca por excelencia de Python para trabajar con grafos y redes. Permite crear, manipular y estudiar su estructura.
\\
Características:
\begin{itemize}
	\item Estructuras de datos para grafos simples, grafos dirigidos y multigrafos.
	\item Contiene la gran parte de algoritmos utilizados para el estudio y modificación de grafos.
	\item Los nodos pueden ser <<cualquier cosa>> como por ejemplo texto, imágenes o números.
	\item Los arcos pueden tener diferentes atributos o datos, como el peso, distancia\dots
	\item Es de código abierto.
\end{itemize}


\subsubsection{Tube Map - D3}
//incluir estructura archivo JSON y explicar lo que significan las diferentes opciones de dirección.
Esta biblioteca permite dibujar mapas muy similares a los mapas que hoy podemos ver en el metro, con sus estaciones, paradas e intersecciones.
\\
Se intentó implementar en el proyecto durante dos Sprints, pero se llegó a la conclusión que no se podía generar la estructura necesaria en el archivo JSON para el dibujado del mapa. Esta estructura debía contener coordenadas con números enteros y estar ordenadas de tal forma que se indicasen las esquinas y cruces que debía haber.

\subsection{Entorno de desarrollo Integrado (IDE)}
Para el desarrollo del proyecto, se valoraron inicialmente dos editores:
\begin{itemize}
	\item Visual Studio Code
	\item PyCharm
\end{itemize}
Al inicio del proyecto se empezó trabajando con Visual Studio Code, pero tras darle una vuelta más se decidió usar Pycharm, ya que al estar orientado el proyecto a Python este IDE ofreceía mejores opciones para el desarrollo.


\subsection{Google API}
En este proyecto, para la selección de los distintos puntos a recorrer por parte del usuario he empleado los mapas de Google. Google proporciona una plataforma para los desarrolladores en la que se puede encontrar una gran cantidad de documentación\footnote{\url{https://cloud.google.com/maps-platform/}}.
Para poder integrar en la aplicación web tanto los mapas como las diferentes funcionalidades que ofrecen debemos adquirir lo que llama API~Key\footnote{\url{https://developers-dot-devsite-v2-prod.appspot.com/maps/documentation/geocoding/get-api-key}}, la cual se trata de una clave <<privada>> para tener acceso a los servicios de su API. Para su obtención es necesario incluir tus datos bancarios, ya que durante el primer año el uso de los servicios es gratis y luego comienza a pagarse a partir de un determinado número de peticiones.
Una vez obtenida la clave, puede restringirse su uso para ciertas direcciones o dominios, de modo que puedes mantener el control de quien la usa. Además, no vale con conseguir una clave y ya esta, si no que para usar los diferentes servicios que proporciona Google hay que activar diferentes APIs.
Las APIs que se usan en este proyecto son:
\begin{itemize}
	\item \textbf{Maps JavaScript API}: Se utiliza en el cliente, de manera que se muestra el mapa al cargar la página y permite realizar diferentes acciones en él; tales como buscar, seleccionar puntos o moverte a traves de él. Algunas de estas acciones implican el uso de algunas de funcionalidades que proporcionan las APIs explicadas a continuación.
	\item \textbf{Geocoding API}: este API consta de dos elementos:
	\begin{itemize}
		\item Geocodificación: Consiste en convertir direcciones en coordenadas.
		\item Geocodificación inversa: Consiste en convertir coordenadas en una dirección legible.
	\end{itemize}
	\item \textbf{Places API}: este servicio devuelve como resultado de la petición toda la información acerca de un lugar.
	\item \textbf{Distance Matrix API}: este API proporciona tanto la distancia como el tiempo de viaje que hay entre una lista de orígenes y una de destinos. En otras palabras, como resultado devuelve la distancia y tiempo que hay entre cada origen y cada destino.
	\item \textbf{Directions API}: como respuesta nos devuelve las indicaciones a seguir para llegar desde el punto de inicio hasta el punto de destino. Además, puede configurarse para diferentes modos de trasporte, diferentes momentos de salida o llegada.
\end{itemize}




\subsection{Documentación}



